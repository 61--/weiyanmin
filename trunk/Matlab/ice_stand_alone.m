function varargout = ice(varargin)
%ICE Interactive Color Editor.
%
%   OUT = ICE('Property Name', 'Property Value', ...) transforms
%   an image's color components based on interactively specified
%   mapping functions. Inputs are Property Name/Property Value pairs: 
%
%     Name            Value
%     ------------    -------------------------------------------------
%     'image'         An RGB or monochrome input image to be transformed
%                     by interactively specified mappings.
%     'space'         The color space of the components to be modified.
%                     Possible values are 'rgb', 'cmy', 'hsi',
%                     'hsv', 'ntsc' (or 'yiq'), 'ycbcr'. When omitted,
%                     the RGB color space is assumed.
%     'wait'          If 'on' (the default), OUT is the mapped input image
%                     and ICE returns to the calling function or workspace
%                     when closed. If 'off', OUT is the handle of the mapped
%                     input image and ICE returns immediately.
%
%   EXAMPLES:
%     ice                                  % Demo curves mode
%     ice('image', f)                      % Map RGB or mono image
%     ice('image', f, 'space', 'hsv')      % Map HSV of RGB image
%     g = ice('image', f, 'wait', 'off');  % Return with handles of g
%
%   ICE displays one popup menu selectable mapping function at a time.
%   Each image component is mapped by a dedicated curve (e.g., R, G,
%   or B) and then bt an all-component curve (e.g., RGB). Each curve's
%   control points are depicted as circles that can be moved, added,
%   or deleted with a three-button mouse:
%
%     Mouse Button    Editing Operation
%     ------------    -------------------------------------------------
%     Left            Move control point by pressing and dragging.
%     Middle          Add and position a control point by pressing
%                     and dragging. (Optionally Shift-Left)
%     Right           Deleted a control point. (Optionally Control-Left)
%
%   Checkboxes determine how  mapping function are computed, whether
%   the input image and reference pseudo- and full-color bars are
%   mapped, and the displayed reference curve information (e.g., PDF):
%
%     Checkbox        Function
%     ------------    -------------------------------------------------
%     Smooth          Checked for cubic spline (smooth curve) interpo-
%                     lation. If unchecked, piecewise linear.
%     Clamp Ends      Checked to force the starting and ending curve
%                     slopes in cubic spline interpolation to 0. No
%                     effect on piecewise linear.
%     Show PDF        Display probablity density function(s) [i.e.,
%                     histogram(s)] of the image components effected by
%                     the mapping function.
%     Show CDF        Display cumulative distributions function(s)
%                     instead of PDFs.
%                     <Note: Show PDF/CDF are mutually exclusive.>
%     Map Image       If checked, image mapping is enabled; else not.
%     Map Bars        If checked, pseudo- and full-color bar mapping is
%                     enabled; else display th eunmapped bars (a gray
%                     wedge and hue wedge, respectively).
%
%   Mapping functions can be initialized via pushbuttons:
%
%     Button          Function
%     ------------    -------------------------------------------------
%     Reset           Init the currently displayed mapping function
%                     and uncheck all curve parameters.
%     Reset All       Initalize all mapping functions.

%   Copyright 2002-2004 R. C. Gonzalez, R. E. Woods, & S. L. Eddins
%   Digital Image Processing Using MATLAB, Prentice-Hall, 2004
%   $Revision: 1.2 $  $Date: 2003/02/19 22:10:00 $

gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @ice_OpeningFcn, ...
                   'gui_OutputFcn',  @ice_OutputFcn, ...
                   'gui_LayoutFcn',  @ice_LayoutFcn, ...
                   'gui_Callback',   []);
if nargin & isstr(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end

%-------------------------------------------------------------------%
function ice_OpeningFcn(hObject, eventdata, handles, varargin)
%  When ICE is opened, perform basic initialization (e.g., setup
%  globals, ...) before it is made visible.

% Set ICE globals to defaults.
handles.updown = 'none';            % Mouse updown state
handles.plotbox = [0 0 1 1];        % Plot area parameters in pixels
handles.set1 = [0 0; 1 1];          % Curve 1 control points
handles.set2 = [0 0; 1 1];          % Curve 2 control points
handles.set3 = [0 0; 1 1];          % Curve 3 control points
handles.set4 = [0 0; 1 1];          % Curve 4 control points
handles.curve = 'set1';             % Structure name of selected curve
handles.cindex = 1;                 % Index of selected curve
handles.node = 0;                   % Index of selected control point
handles.below = 1;                  % Index of node below control point
handles.above = 2;                  % Index of node above control point
handles.smooth = [0; 0; 0; 0];      % Curve smoothing states
handles.slope = [0; 0; 0; 0];       % Curve end slope control states
handles.cdf = [0; 0; 0; 0];         % Curve CDF states
handles.pdf = [0; 0; 0; 0];         % Curve PDF states
handles.output = [];                % Output image handle
handles.df = [];                    % Input PDFs and CDFs
handles.colortype = 'rgb';          % Input image color space
handles.input = [];                 % Input image data
handles.imagemap = 1;               % Image map enable
handles.barmap = 1;                 % Bar map enable
handles.graybar = [];               % Pseudo (gray) bar image
handles.colorbar = [];              % Color (hue) bar image

% Process Property Name/Property Value input argument pairs.
wait = 'on';
if(nargin > 3)
    for i = 1: 2: (nargin - 3),
        if nargin - 3 == i break;  end
        switch lower(varargin{i})
            case 'image'
            if ndims(varargin{i + 1}) == 3
                handles.input = varargin{i + 1};
            elseif ndims(varargin{i + 1}) == 2
                handles.input = cat(3, varargin{i + 1}, ...
                    varargin{i + 1}, varargin{i + 1});  end;
            handles.input = double(handles.input);
            inputmax = max(handles.input(:));
            if inputmax > 255   handles.input = handles.input / 65535;
            elseif inputmax > 1
            handles.input = handles.input / 255;    end
        
            case 'space'
                handles.colortype = lower(varargin{i + 1});
                switch handles.colortype
                    case 'cmy',  list = {'CMY' 'Cyan' 'Magenta' 'Yellow'};
                    case {'ntsc', 'yiq'}
                        list = {'YIQ' 'Luminance' 'Hue' 'Saturation'};
                        handles.colortype = 'ntsc';
                    case 'ycbcr',    list = {'YCbCr' 'Luminance' 'Blue' ...
                        'Difference'  'Red Difference'};
                    case 'hsv',  list = {'HSV' 'Hue' 'Saturation' 'Value'};
                    case 'hsi',  list = {'HSI' 'Hue' 'Saturation' 'Intensity'};
                    otherwise
                        list = {'RGB' 'Red' 'Green' 'Blue'};
                        handles.colortype = 'rgb';
                end
                set(handles.component_popup, 'String', list);
            
            case 'wait', wait = lower(varargin{i + 1});
        end
    end
end
   
% Create pseudo- and full-color mapping bars (grays and hues). Store a
% color space converted 1x128x3 line of each bar for mapping.
xi = 0: 1/127: 1;          x = 0: 1 / 6: 1;     x = x';
y = [1 1 0 0 0 1 1; 0 1 1 1 0 0 0; 0 0 0 1 1 1 0]';
gb = repmat(xi, [1 1 3]);       cb = interp1q(x, y, xi');
cb = reshape(cb, [1 128 3]);
if ~strcmp(handles.colortype, 'rgb')
    gb = eval(['rgb2' handles.colortype '(gb)']);
    cb = eval(['rgb2' handles.colortype '(cb)']);   end
gb = round(255 * gb);     gb = max(0, gb);      gb = min(255, gb);
cb = round(255 * cb);     cb = max(0, cb);      cb = min(255, cb);
handles.graybar = gb;     handles.colorbar = cb;

% Do color space transforms, clamp to [0, 255], compute histograms
% and cumulative distribution functions, and create output figure.
if size(handles.input, 1)
    if ~strcmp(handles.colortype, 'rgb')
        handles.input = eval(['rgb2' handles.colortype ...
            '(handles.input)']);    end
    handles.input = round(255 * handles.input);
    handles.input = max(0, handles.input);
    handles.input = min(255, handles.input);
    for i = 1: 3
        color = handles.input(:, :, i);
        df = hist(color(:), 0: 255);
        handles.df = [handles.df; df / max(df(:))];
        df = df / sum(df(:));   df = cumsum(df);
        handles.df = [handles.df; df];
    end
    figure;     handles.output = gcf;
end

% Compute ICE's screen position and display image/graph.
set(0, 'Units', 'pixels');      ssz = get(0, 'Screensize');
set(handles.ice, 'Units', 'pixels');
uisz = get(handles.ice, 'Position');
if size(handles.input, 1)
    fsz = get(handles.output, 'Position');
    bc = (fsz(4) - uisz(4)) / 3;
    if bc > 0    bc = bc + fsz(2);
    else bc = fsz(2) + fsz(4) - uisz(4) - 10;  end
    lc = fsz(1) + (size(handles.input, 2) / 4) + (3 * fsz(3) / 4);
    lc = min(lc, ssz(3) - uisz(3) - 10);
    set(handles.ice, 'Position', [lc bc 463 391]);
else
    bc = round((ssz(4) - uisz(4)) / 2) - 10;
    lc = round((ssz(3) - uisz(3)) / 2) - 10;
    set(handles.ice, 'Position', [lc bc uisz(3) uisz(4)]);
end
set(handles.ice, 'Units', 'normalized');
graph(handles);     render(handles);

% Update handles and Make ICE wait before exit if required.
guidata(hObject, handles);
if strcmpi(wait, 'on')  uiwait(handles.ice);    end

%-------------------------------------------------------------------%
function varargout = ice_OutputFcn(hObject, eventdata, handles)
%  After ICE is closed, get the image data of the current figure
%  for the output. If 'handles' exists, ICE isn’t closed (there was
%  no 'uiwait') so output figure handle.

if max(size(handles)) == 0
    figh = get(gcf);
    imageh = get(figh.Children);
    if max(size(imageh)) > 0
        image = get(imageh.Children);
        varargout{1} = image.CData;
    end
else    varargout{1} = hObject;  end

%-------------------------------------------------------------------%
function ice_WindowButtonDownFcn(hObject, eventdata, handles)
%  Start mapping function control point editing. Do move, add, or
%  delete for left, middle, and right button mouse clicks ('normal',
%  'extend', and 'alt' cases) over plot area.

set(handles.curve_axes, 'Units', 'pixels');
handles.plotbox = get(handles.curve_axes, 'Position');
set(handles.curve_axes, 'Units', 'normalized');
[inplot, x, y] = cursor(hObject, handles);
if inplot
    nodes = getfield(handles, handles.curve);
    i = find(x >= nodes(:, 1));      below = max(i);
    above = min(below + 1, size(nodes, 1));
    if (x - nodes(below, 1)) > (nodes(above, 1) - x)    node = above;
    else  node = below;    end
    deletednode = 0;
    
    switch get(hObject, 'SelectionType')
        case 'normal'
        if node == above    above = min(above + 1, size(nodes, 1));
        elseif node == below    below = max(below - 1, 1);      end
        if node == size(nodes, 1)   below = above;
        elseif node == 1    above = below;      end
        if x > nodes(above, 1)  x = nodes(above, 1);
        elseif x < nodes(below, 1)  x = nodes(below, 1);    end
        handles.node = node;    handles.updown = 'down';
        handles.below = below;  handles.above = above;
        nodes(node, :) = [x y];
        case 'extend'
            if ~length(find(nodes(:, 1) == x))
                nodes = [nodes(1: below, :); [x y]; nodes(above: end, :)];
                handles.node = above;   handles.updown = 'down';
                handles.below = below;  handles.above = above + 1;
            end
        case 'alt'
            if (node ~= 1) & (node ~= size(nodes, 1))
                nodes(node, :) = [];    deletednode = 1;    end
            handles.node = 0;
            set(handles.input_text, 'String', '');
            set(handles.output_text, 'String', '');
    end

    handles = setfield(handles, handles.curve, nodes);
    guidata(hObject, handles);
    graph(handles);
    if deletednode  render(handles);    end
end

%-------------------------------------------------------------------%
function ice_WindowButtonMotionFcn(hObject, eventdata, handles)
%  Do nothing unless a mouse 'down' event has occurred. If it has,
%  modify control point and make new mapping function. 

if ~strcmpi(handles.updown, 'down') return;  end
[inplot, x, y] = cursor(hObject, handles);
if inplot
    nodes = getfield(handles, handles.curve);
    nudge = handles.smooth(handles.cindex) / 256;
    if (handles.node ~= 1) & (handles.node ~= size(nodes, 1))
        if x >= nodes(handles.above, 1)
            x = nodes(handles.above, 1) - nudge;
        elseif x <= nodes(handles.below, 1)
            x = nodes(handles.below, 1) + nudge;    end
    else
        if x > nodes(handles.above, 1)
            x = nodes(handles.above, 1);
        elseif x < nodes(handles.below, 1)
            x = nodes(handles.below, 1);    end
    end
    nodes(handles.node, :) = [x y];
    handles = setfield(handles, handles.curve, nodes);
    guidata(hObject, handles);
    graph(handles);
end

%-------------------------------------------------------------------%
function ice_WindowButtonUpFcn(hObject, eventdata, handles)
%  Terminate ongoing control point move or add operation. Clear
%  coordinate text below plot and update display.

update = strcmpi(handles.updown, 'down');
handles.updown = 'up';      handles.node = 0;
guidata(hObject, handles);
if update
    set(handles.input_text, 'String', '');
    set(handles.output_text, 'String', '');
    render(handles);
end

%-------------------------------------------------------------------%
function component_popup_Callback(hObject, eventdata, handles)
%  Accept color component selection, update component specific
%  parameters on GUI, and draw the selected mapping function.

c = get(hObject, 'Value');
handles.cindex = c;
handles.curve = strcat('set', num2str(c));
guidata(hObject, handles);
set(handles.smooth_checkbox, 'Value', handles.smooth(c));
set(handles.slope_checkbox, 'Value', handles.slope(c));
set(handles.pdf_checkbox, 'Value', handles.pdf(c));
set(handles.cdf_checkbox, 'Value', handles.cdf(c));
graph(handles);

%-------------------------------------------------------------------%
function smooth_checkbox_Callback(hObject, eventdata, handles)
%  Accept smoothing parameter for currently selected color
%  component and redraw mapping function.

if get(hObject, 'Value')
    handles.smooth(handles.cindex) = 1;
    nodes = getfield(handles, handles.curve);
    nodes = spreadout(nodes);
    handles = setfield(handles, handles.curve, nodes);
else handles.smooth(handles.cindex) = 0;    end
guidata(hObject, handles);
set(handles.ice, 'Pointer', 'watch');
graph(handles);      render(handles);
set(handles.ice, 'Pointer', 'arrow');

%-------------------------------------------------------------------%
function reset_pushbutton_Callback(hObject, eventdata, handles)
%  Init all display parameters for currently selected color
%  component, make map 1:1, and redraw it.

handles = setfield(handles, handles.curve, [0 0; 1 1]);
c = handles.cindex;
handles.smooth(c) = 0;  set(handles.smooth_checkbox, 'Value', 0);
handles.slope(c) = 0;   set(handles.slope_checkbox, 'Value', 0);
handles.pdf(c) = 0;     set(handles.pdf_checkbox, 'Value', 0);
handles.cdf(c) = 0;     set(handles.cdf_checkbox, 'Value', 0);
guidata(hObject, handles);
set(handles.ice, 'Pointer', 'watch');
graph(handles);      render(handles);
set(handles.ice, 'Pointer', 'arrow');

%-------------------------------------------------------------------%
function slope_checkbox_Callback(hObject, eventdata, handles)
%  Accept slope clamp for currently selected color component and
%  draw function if smoothing is on.

if get(hObject, 'Value')
    handles.slope(handles.cindex) = 1;
else handles.slope(handles.cindex) = 0;    end
    guidata(hObject, handles);
if handles.smooth(handles.cindex)
    set(handles.ice, 'Pointer', 'watch');
    graph(handles);      render(handles);
    set(handles.ice, 'Pointer', 'arrow');   end

%-------------------------------------------------------------------%
function resetall_pushbutton_Callback(hObject, eventdata, handles)
%  Init display parameters for color components, make all maps 1:1,
%  and redraw display.

for c = 1: 4
    handles.smooth(c) = 0;      handles.slope(c) = 0;
    handles.pdf(c) = 0;         handles.cdf(c) = 0;
    handles = setfield(handles, ['set' num2str(c)], [0 0; 1 1]);
end
set(handles.smooth_checkbox, 'Value', 0);
set(handles.slope_checkbox, 'Value', 0);
set(handles.pdf_checkbox, 'Value', 0);
set(handles.cdf_checkbox, 'Value', 0);
guidata(hObject, handles);
set(handles.ice, 'Pointer', 'watch');
graph(handles);      render(handles);
set(handles.ice, 'Pointer', 'arrow');

%-------------------------------------------------------------------%
function pdf_checkbox_Callback(hObject, eventdata, handles)
%  Accept PDF (probability density function or histogram) display
%  parameter for currently selected color component and redraw
%  mapping function if smoothing is on. If set, clear CDF display.

function pdf_checkbox_Callback(hObject, eventdata, handles)
if get(hObject, 'Value')
    handles.pdf(handles.cindex) = 1;
    set(handles.cdf_checkbox, 'Value', 0);
    handles.cdf(handles.cindex) = 0;
else handles.pdf(handles.cindex) = 0;    end
guidata(hObject, handles);      graph(handles);

%-------------------------------------------------------------------%
function cdf_checkbox_Callback(hObject, eventdata, handles)
%  Accept CDF (cumulative distribution function) display parameter
%  for selected color component and redraw mapping function if
%  smoothing is on. If set, clear CDF display.

if get(hObject, 'Value')
    handles.cdf(handles.cindex) = 1;
    set(handles.pdf_checkbox, 'Value', 0);
    handles.pdf(handles.cindex) = 0;
else handles.cdf(handles.cindex) = 0;    end
guidata(hObject, handles);      graph(handles);

%-------------------------------------------------------------------%
function mapbar_checkbox_Callback(hObject, eventdata, handles)
%  Accept changes to bar map enable state and redraw bars.

handles.barmap = get(hObject, 'Value');
guidata(hObject, handles);      render(handles);

%-------------------------------------------------------------------%
function mapimage_checkbox_Callback(hObject, eventdata, handles)
%  Accept changes to the image map state and redraw image.

function mapimage_checkbox_Callback(hObject, eventdata, handles)
handles.imagemap = get(hObject, 'Value');
guidata(hObject, handles);      render(handles);

%-------------------------------------------------------------------%
function graph(handles)
%  Interpolate and plot mapping functions and optional reference
%  PDF(s) or CDF(s).

nodes = getfield(handles, handles.curve);
c = handles.cindex;     dfx = 0: 1/255: 1;
colors = ['k' 'r' 'g' 'b'];

% For piecewise linear interpolation, plot a map, map + PDF/CDF, or
% map + 3 PDFs/CDFs.
if ~handles.smooth(handles.cindex)
    if (~handles.pdf(c) & ~handles.cdf(c)) | ...
            (size(handles.df, 2) == 0)
        plot(nodes(:, 1), nodes(:, 2), 'b-', ...
            nodes(:, 1),  nodes(:, 2), 'ko', ...
            'Parent', handles.curve_axes);
    elseif c > 1
        i = 2 * c - 2 - handles.pdf(c);
        plot(dfx, handles.df(i, :), [colors(c) '-'], ...
            nodes(:, 1), nodes(:, 2), 'k-', ...
            nodes(:, 1), nodes(:, 2), 'ko', ...
            'Parent', handles.curve_axes);
    elseif c == 1
        i = handles.cdf(c);
        plot(dfx, handles.df(i + 1, :), 'r-', ...
            dfx, handles.df(i + 3, :), 'g-',  ...
            dfx, handles.df(i + 5, :), 'b-', ...
            nodes(:, 1), nodes(:, 2), 'k-',  ...
            nodes(:, 1), nodes(:, 2), 'ko', ...
            'Parent', handles.curve_axes);
    end

% Do the same for smooth (cubic spline) interpolations.
else
    x = 0: 0.01: 1;
    if ~handles.slope(handles.cindex)
        y = spline(nodes(:, 1), nodes(:, 2), x);
    else    y = spline(nodes(:, 1), [0; nodes(:, 2); 0], x);    end
    i = find(y > 1);       y(i) = 1;
    i = find(y <0);        y(i) = 0;

    if (~handles.pdf(c) & ~handles.cdf(c)) | ...
            (size(handles.df, 2) == 0)
        plot(nodes(:, 1), nodes(:, 2), 'ko',  x, y, 'b-', ...
            'Parent', handles.curve_axes);
    elseif c > 1
        i = 2 * c - 2 - handles.pdf(c);
        plot(dfx, handles.df(i, :), [colors(c) '-'], ...
            nodes(:, 1), nodes(:, 2), 'ko', x, y, 'k-', ...
            'Parent', handles.curve_axes);
    elseif c == 1
        i = handles.cdf(c);
        plot(dfx, handles.df(i + 1, :), 'r-', ...
            dfx, handles.df(i + 3, :), 'g-', ...
            dfx, handles.df(i + 5, :), 'b-', ...
            nodes(:, 1), nodes(:, 2), 'ko', x, y, 'k-', ...
            'Parent', handles.curve_axes);
    end
end

% Put legend if more than two curves are shown.
s = handles.colortype;
if strcmp(s, 'ntsc')
    s = 'yiq';  end
if (c == 1) & (handles.pdf(c) | handles.cdf(c))
    s1 = ['-- ' upper(s(1))];
    if length(s) == 3
        s2 = ['-- ' upper(s(2))];       s3 = ['-- ' upper(s(3))];
    else
        s2 = ['-- ' upper(s(2)) s(3)];  s3 = ['-- ' upper(s(4)) s(5)];
    end
else    s1 = '';    s2 = '';    s3 = '';    end
set(handles.red_text, 'String', s1);
set(handles.green_text, 'String', s2);
set(handles.blue_text, 'String', s3);

%-------------------------------------------------------------------%
function [inplot, x, y] = cursor(h, handles)
%  Translate the mouse position to a coordinate with respect to
%  the current plot area, check for the mouse in the area and if so
%  save the location and write the coordinates below the plot.

set(h, 'Units', 'pixels');
p = get(h, 'CurrentPoint');
x = (p(1, 1) - handles.plotbox(1)) / handles.plotbox(3);
y = (p(1, 2) - handles.plotbox(2)) / handles.plotbox(4);
if x > 1.05 | x < -0.05 | y > 1.05 | y < -0.05
    inplot = 0;
else
    x = min(x, 1);      x = max(x, 0);
    y = min(y, 1);      y = max(y, 0);
    nodes = getfield(handles, handles.curve);
    x = round(256 * x) / 256;
    inplot = 1;
    set(handles.input_text, 'String', num2str(x, 3));
    set(handles.output_text, 'String', num2str(y, 3));
end
set(h, 'Units', 'normalized');

%-------------------------------------------------------------------%
function y = render(handles)
%  Map the input image and bar components and convert them to RGB
%  (if needed) and display.

set(handles.ice, 'Interruptible', 'off');
set(handles.ice, 'Pointer', 'watch');
ygb = handles.graybar;      ycb = handles.colorbar;
yi = handles.input;         mapon = handles.barmap;
imageon = handles.imagemap & size(handles.input, 1);

for i = 2: 4
    nodes = getfield(handles, ['set' num2str(i)]);
    t = lut(nodes, handles.smooth(i), handles.slope(i));
    if imageon  yi(:, :, i - 1) = t(yi(:, :, i - 1) + 1);   end
    if mapon    ygb(:, :, i - 1) = t(ygb(:, :, i - 1) + 1);
        ycb(:, :, i - 1) = t(ycb(:, :, i - 1) + 1);     end
end
t = lut(handles.set1, handles.smooth(1), handles.slope(1));
if imageon  yi = t(yi + 1);     end
if mapon    ygb = t(ygb + 1);     ycb = t(ycb + 1);     end
   
if ~strcmp(handles.colortype, 'rgb')
    if size(handles.input, 1)
        yi = yi / 255;
        yi = eval([handles.colortype '2rgb(yi)']);
        yi = uint8(255 * yi);   end
        ygb = ygb / 255;        ycb = ycb / 255;
        ygb = eval([handles.colortype '2rgb(ygb)']);
        ycb = eval([handles.colortype '2rgb(ycb)']);
        ygb = uint8(255 * ygb);     ycb = uint8(255 * ycb);
else
    yi = uint8(yi);   ygb = uint8(ygb);     ycb = uint8(ycb);   end

if size(handles.input, 1)
    figure(handles.output);    imshow(yi);      end
ygb = repmat(ygb, [32 1 1]);    ycb = repmat(ycb, [32 1 1]);
axes(handles.gray_axes);        imshow(ygb);
axes(handles.color_axes);       imshow(ycb);
figure(handles.ice);
set(handles.ice, 'Pointer', 'arrow');
set(handles.ice, 'Interruptible', 'on');

%-------------------------------------------------------------------%
function t = lut(nodes, smooth, slope)
%  Create a 256 element mapping function from a set of control
%  points. The output values are integers in the interval [0, 255].
%  Use piecewise linear or cubic spline with or without zero end
%  slope interpolation.

t = 255 * nodes;    i = 0:255;
if ~smooth  t = [t; 256 256];   t = interp1q(t(:, 1), t(:, 2), i');
else
    if ~slope   t = spline(t(:, 1), t(:, 2), i);
    else        t = spline(t(:, 1), [0; t(:, 2); 0], i);    end
end
t = round(t);       t = max(0, t);          t = min(255, t);

%-------------------------------------------------------------------%
function out = spreadout(in)
%  Make all x values unique.

% Scan forward for non-unique x's and bump the higher indexed x--
% but don't exceed 1. Scan the entire range.
nudge = 1 / 256;
for i = 2: size(in, 1) - 1
    if in(i, 1) <= in(i - 1, 1)
        in(i, 1) = min(in(i - 1, 1) + nudge, 1);  end
end

% Scan in reverse for non-unique x's and decrease the lower indexed
% x -- but don't go below 0. Stop on the first non-unique pair.
if in(end, 1) == in(end - 1, 1)
    for i = size(in, 1): -1: 2
        if in(i, 1) <= in(i - 1, 1)
            in(i - 1, 1) = max(in(i, 1) - nudge, 0);
        else break; end
    end
end

% If the first two x's are now the same, init the curve.
if in(1, 1) == in(2, 1)     in = [0 0; 1 1];    end
out = in;

% --- Creates and returns a handle to the GUI figure. 
function h1 = ice_LayoutFcn(policy)
% policy - create a new figure or use a singleton. 'new' or 'reuse'.

persistent hsingleton;
if strcmpi(policy, 'reuse') & ishandle(hsingleton)
    h1 = hsingleton;
    return;
end

h1 = figure(...
'Units','characters',...
'Color',[0.87843137254902 0.874509803921569 0.890196078431373],...
'Colormap',[0 0 0.5625;0 0 0.625;0 0 0.6875;0 0 0.75;0 0 0.8125;0 0 0.875;0 0 0.9375;0 0 1;0 0.0625 1;0 0.125 1;0 0.1875 1;0 0.25 1;0 0.3125 1;0 0.375 1;0 0.4375 1;0 0.5 1;0 0.5625 1;0 0.625 1;0 0.6875 1;0 0.75 1;0 0.8125 1;0 0.875 1;0 0.9375 1;0 1 1;0.0625 1 1;0.125 1 0.9375;0.1875 1 0.875;0.25 1 0.8125;0.3125 1 0.75;0.375 1 0.6875;0.4375 1 0.625;0.5 1 0.5625;0.5625 1 0.5;0.625 1 0.4375;0.6875 1 0.375;0.75 1 0.3125;0.8125 1 0.25;0.875 1 0.1875;0.9375 1 0.125;1 1 0.0625;1 1 0;1 0.9375 0;1 0.875 0;1 0.8125 0;1 0.75 0;1 0.6875 0;1 0.625 0;1 0.5625 0;1 0.5 0;1 0.4375 0;1 0.375 0;1 0.3125 0;1 0.25 0;1 0.1875 0;1 0.125 0;1 0.0625 0;1 0 0;0.9375 0 0;0.875 0 0;0.8125 0 0;0.75 0 0;0.6875 0 0;0.625 0 0;0.5625 0 0],...
'IntegerHandle','off',...
'InvertHardcopy',get(0,'defaultfigureInvertHardcopy'),...
'MenuBar','none',...
'Name','ICE - Interactive Color Editor',...
'NumberTitle','off',...
'PaperPosition',get(0,'defaultfigurePaperPosition'),...
'Position',[0.8 65.2307692307693 92.6 30.0769230769231],...
'Renderer',get(0,'defaultfigureRenderer'),...
'RendererMode','manual',...
'WindowButtonDownFcn','ice(''ice_WindowButtonDownFcn'',gcbo,[],guidata(gcbo))',...
'WindowButtonMotionFcn','ice(''ice_WindowButtonMotionFcn'',gcbo,[],guidata(gcbo))',...
'WindowButtonUpFcn','ice(''ice_WindowButtonUpFcn'',gcbo,[],guidata(gcbo))',...
'HandleVisibility','callback',...
'Tag','ice',...
'UserData',zeros(1,0));

setappdata(h1, 'GUIDEOptions', struct(...
'active_h', 1.230002e+002, ...
'taginfo', struct(...
'figure', 2, ...
'text', 12, ...
'popupmenu', 2, ...
'axes', 4, ...
'checkbox', 7, ...
'pushbutton', 3, ...
'frame', 2), ...
'override', 0, ...
'resize', 'simple', ...
'accessibility', 'callback', ...
'mfile', 1, ...
'callbacks', 1, ...
'singleton', 1, ...
'blocking', 0, ...
'syscolorfig', 0, ...
'release', 12, ...
'lastSavedFile', 'C:\MATLAB6p5\work\ice.m'));

h2 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'ListboxTop',0,...
'Position',[0.678185745140389 0.478260869565217 0.27645788336933 0.388746803069054],...
'String',{ '' },...
'Style','frame',...
'Tag','frame1');

h3 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'CData',zeros(1,0),...
'FontSize',12,...
'FontWeight','bold',...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.0539956803455724 0.91304347826087 0.21598272138229 0.051150895140665],...
'String','Component:',...
'Style','text',...
'Tag','text1',...
'UserData',zeros(1,0));

h4 = axes(...
'Parent',h1,...
'Box','on',...
'CameraPosition',[0.5 0.5 9.16025403784439],...
'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
'Color',get(0,'defaultaxesColor'),...
'ColorOrder',get(0,'defaultaxesColorOrder'),...
'NextPlot','replacechildren',...
'Position',[0.0799136069114471 0.21227621483376 0.552915766738661 0.654731457800512],...
'XColor',get(0,'defaultaxesXColor'),...
'XGrid','on',...
'XLim',get(0,'defaultaxesXLim'),...
'XLimMode','manual',...
'XTick',[0 0.25 0.5 0.75 1],...
'XTickMode','manual',...
'YColor',get(0,'defaultaxesYColor'),...
'YGrid','on',...
'YLim',get(0,'defaultaxesYLim'),...
'YLimMode','manual',...
'YTick',[0 0.25 0.5 0.75 1],...
'YTickMode','manual',...
'ZColor',get(0,'defaultaxesZColor'),...
'Tag','curve_axes');

h5 = get(h4,'title');

set(h5,...
'Parent',h4,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.498263888888889 1.02256944444444 9.16025403784439],...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h6 = get(h4,'xlabel');

set(h6,...
'Parent',h4,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.498263888888889 -0.0815972222222223 9.16025403784439],...
'VerticalAlignment','cap',...
'HandleVisibility','off');

h7 = get(h4,'ylabel');

set(h7,...
'Parent',h4,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[-0.123263888888889 0.494791666666667 9.16025403784439],...
'Rotation',90,...
'VerticalAlignment','baseline',...
'HandleVisibility','off');

h8 = get(h4,'zlabel');

set(h8,...
'Parent',h4,...
'Color',[0 0 0],...
'HorizontalAlignment','right',...
'Position',[-0.130208333333333 1.16145833333333 9.16025403784439],...
'HandleVisibility','off',...
'Visible','off');

h9 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''component_popup_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.282937365010799 0.910485933503837 0.356371490280778 0.0588235294117647],...
'String',{ 'RGB' 'Red' 'Green' 'Blue' },...
'Style','popupmenu',...
'Value',1,...
'Tag','component_popup');

h10 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontSize',10,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.110151187904968 0.071611253196931 0.107991360691145 0.0639386189258312],...
'String','Input:',...
'Style','text',...
'Tag','text2');

h11 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontSize',10,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.0907127429805616 0.0127877237851662 0.107991360691145 0.0639386189258312],...
'String','Output:',...
'Style','text',...
'Tag','text3');

h12 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''smooth_checkbox_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.717062634989201 0.777493606138107 0.187904967602592 0.061381074168798],...
'String','Smooth',...
'Style','checkbox',...
'Tag','smooth_checkbox');

h13 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''reset_pushbutton_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.710583153347732 0.508951406649616 0.211663066954644 0.0767263427109974],...
'String','Reset',...
'Tag','reset_pushbutton');

h14 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontAngle','italic',...
'FontSize',12,...
'ListboxTop',0,...
'Position',[0.747300215982722 0.831202046035806 0.144708423326134 0.0562659846547315],...
'String','Curve',...
'Style','text',...
'Tag','text4');

h15 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'BackgroundColor',[0.752941176470588 0.752941176470588 0.752941176470588],...
'FontSize',12,...
'ForegroundColor',[1 0 0],...
'ListboxTop',0,...
'Position',[0.198704103671706 0.0920716112531969 0.107991360691145 0.040920716112532],...
'String','',...
'Style','text',...
'Tag','input_text');

h16 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'BackgroundColor',[0.752941176470588 0.752941176470588 0.752941176470588],...
'FontSize',12,...
'ForegroundColor',[1 0 0],...
'ListboxTop',0,...
'Position',[0.198704103671706 0.0332480818414322 0.107991360691145 0.040920716112532],...
'String','',...
'Style','text',...
'Tag','output_text');

h17 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''slope_checkbox_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.717062634989201 0.718670076726343 0.213822894168467 0.061381074168798],...
'String','Clamp Ends',...
'Style','checkbox',...
'Tag','slope_checkbox');

h18 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''resetall_pushbutton_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.678185745140389 0.0460358056265985 0.27645788336933 0.0767263427109974],...
'String','Reset All',...
'Tag','resetall_pushbutton');

h19 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''pdf_checkbox_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.717062634989201 0.659846547314578 0.187904967602592 0.061381074168798],...
'String','Show PDF',...
'Style','checkbox',...
'Tag','pdf_checkbox');

h20 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''cdf_checkbox_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.717062634989201 0.601023017902813 0.187904967602592 0.061381074168798],...
'String','Show CDF',...
'Style','checkbox',...
'Tag','cdf_checkbox');

h21 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontSize',12,...
'ForegroundColor',[0 0 1],...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.347732181425486 0.010230179028133 0.0863930885529158 0.051150895140665],...
'String','',...
'Style','text',...
'Tag','blue_text');

h22 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'CData',zeros(1,0),...
'FontSize',12,...
'ForegroundColor',[0 1 0],...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.347732181425486 0.0537084398976982 0.0863930885529158 0.051150895140665],...
'String','',...
'Style','text',...
'Tag','green_text',...
'UserData',zeros(1,0));

h23 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontSize',12,...
'ForegroundColor',[1 0 0],...
'HorizontalAlignment','left',...
'ListboxTop',0,...
'Position',[0.347732181425486 0.0971867007672634 0.0863930885529158 0.051150895140665],...
'String','',...
'Style','text',...
'Tag','red_text');

h24 = axes(...
'Parent',h1,...
'CameraPosition',[0.5 0.5 9.16025403784439],...
'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
'Color',get(0,'defaultaxesColor'),...
'ColorOrder',get(0,'defaultaxesColorOrder'),...
'Position',[0.678185745140389 0.360613810741688 0.27645788336933 0.0818414322250639],...
'XColor',get(0,'defaultaxesXColor'),...
'XTick',zeros(1,0),...
'XTickLabel','',...
'XTickLabelMode','manual',...
'XTickMode','manual',...
'YColor',get(0,'defaultaxesYColor'),...
'YTick',zeros(1,0),...
'YTickMode','manual',...
'ZColor',get(0,'defaultaxesZColor'),...
'Tag','gray_axes');

h25 = get(h24,'title');

set(h25,...
'Parent',h24,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.49609375 1.203125 1.00005459937205],...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h26 = get(h24,'xlabel');

set(h26,...
'Parent',h24,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.49609375 -0.265625 1.00005459937205],...
'VerticalAlignment','cap',...
'HandleVisibility','off');

h27 = get(h24,'ylabel');

set(h27,...
'Parent',h24,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[-0.05078125 0.453125 1.00005459937205],...
'Rotation',90,...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h28 = get(h24,'zlabel');

set(h28,...
'Parent',h24,...
'Color',[0 0 0],...
'HorizontalAlignment','right',...
'Position',[-2.45703125 7.765625 1.00005459937205],...
'HandleVisibility','off',...
'Visible','off');

h29 = axes(...
'Parent',h1,...
'CameraPosition',[0.5 0.5 9.16025403784439],...
'CameraPositionMode',get(0,'defaultaxesCameraPositionMode'),...
'Color',get(0,'defaultaxesColor'),...
'ColorOrder',get(0,'defaultaxesColorOrder'),...
'Position',[0.678185745140389 0.21227621483376 0.27645788336933 0.0818414322250639],...
'XColor',get(0,'defaultaxesXColor'),...
'XTick',zeros(1,0),...
'XTickMode','manual',...
'YColor',get(0,'defaultaxesYColor'),...
'YTick',zeros(1,0),...
'YTickMode','manual',...
'ZColor',get(0,'defaultaxesZColor'),...
'Tag','color_axes');

h30 = get(h29,'title');

set(h30,...
'Parent',h29,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.49609375 1.203125 1.00005459937205],...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h31 = get(h29,'xlabel');

set(h31,...
'Parent',h29,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[0.49609375 -0.265625 1.00005459937205],...
'VerticalAlignment','cap',...
'HandleVisibility','off');

h32 = get(h29,'ylabel');

set(h32,...
'Parent',h29,...
'Color',[0 0 0],...
'HorizontalAlignment','center',...
'Position',[-0.05078125 0.453125 1.00005459937205],...
'Rotation',90,...
'VerticalAlignment','bottom',...
'HandleVisibility','off');

h33 = get(h29,'zlabel');

set(h33,...
'Parent',h29,...
'Color',[0 0 0],...
'HorizontalAlignment','right',...
'Position',[-2.45703125 9.578125 1.00005459937205],...
'HandleVisibility','off',...
'Visible','off');

h34 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontAngle','italic',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.684665226781857 0.312020460358056 0.259179265658747 0.040920716112532],...
'String','Pseudo-color Bar',...
'Style','text',...
'Tag','text10');

h35 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'FontAngle','italic',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.717062634989201 0.163682864450128 0.192224622030238 0.040920716112532],...
'String','Full-color Bar',...
'Style','text',...
'Tag','text11');

h36 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''mapbar_checkbox_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.436285097192225 0.0818414322250639 0.172786177105832 0.061381074168798],...
'String','Map Bars',...
'Style','checkbox',...
'Value',1,...
'Tag','mapbar_checkbox');

h37 = uicontrol(...
'Parent',h1,...
'Units','normalized',...
'Callback','ice(''mapimage_checkbox_Callback'',gcbo,[],guidata(gcbo))',...
'FontSize',10,...
'ListboxTop',0,...
'Position',[0.436285097192225 0.0230179028132992 0.19438444924406 0.061381074168798],...
'String','Map Image',...
'Style','checkbox',...
'Value',1,...
'Tag','mapimage_checkbox');

hsingleton = h1;


% --- Handles default GUIDE GUI creation and callback dispatch
function varargout = gui_mainfcn(gui_State, varargin)


%   GUI_MAINFCN provides these command line APIs for dealing with GUIs
%
%      ICE, by itself, creates a new ICE or raises the existing
%      singleton*.
%
%      H = ICE returns the handle to a new ICE or the handle to
%      the existing singleton*.
%
%      ICE('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in ICE.M with the given input arguments.
%
%      ICE('Property','Value',...) creates a new ICE or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before untitled_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to untitled_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".

%   Copyright 1984-2002 The MathWorks, Inc.
%   $Revision: 1.2 $ $Date: 2003/02/19 22:10:00 $

gui_StateFields =  {'gui_Name'
                    'gui_Singleton'
                    'gui_OpeningFcn'
                    'gui_OutputFcn'
                    'gui_LayoutFcn'
                    'gui_Callback'};
gui_Mfile = '';
for i=1:length(gui_StateFields)
    if ~isfield(gui_State, gui_StateFields{i})
        error('Could not find field %s in the gui_State struct in GUI M-file %s', gui_StateFields{i}, gui_Mfile);        
    elseif isequal(gui_StateFields{i}, 'gui_Name')
        gui_Mfile = [getfield(gui_State, gui_StateFields{i}), '.m'];
    end
end

numargin = length(varargin);

if numargin == 0
    % ICE
    % create the GUI
    gui_Create = 1;
elseif numargin > 3 & ischar(varargin{1}) & ishandle(varargin{2})
    % ICE('CALLBACK',hObject,eventData,handles,...)
    gui_Create = 0;
else
    % ICE(...)
    % create the GUI and hand varargin to the openingfcn
    gui_Create = 1;
end

if gui_Create == 0
    varargin{1} = gui_State.gui_Callback;
    if nargout
        [varargout{1:nargout}] = feval(varargin{:});
    else
        feval(varargin{:});
    end
else
    if gui_State.gui_Singleton
        gui_SingletonOpt = 'reuse';
    else
        gui_SingletonOpt = 'new';
    end
    
    % Open fig file with stored settings.  Note: This executes all component
    % specific CreateFunctions with an empty HANDLES structure.
    
    % Do feval on layout code in m-file if it exists
    if ~isempty(gui_State.gui_LayoutFcn)
        gui_hFigure = feval(gui_State.gui_LayoutFcn, gui_SingletonOpt);
    else
        gui_hFigure = local_openfig(gui_State.gui_Name, gui_SingletonOpt);            
        % If the figure has InGUIInitialization it was not completely created
        % on the last pass.  Delete this handle and try again.
        if isappdata(gui_hFigure, 'InGUIInitialization')
            delete(gui_hFigure);
            gui_hFigure = local_openfig(gui_State.gui_Name, gui_SingletonOpt);            
        end
    end
    
    % Set flag to indicate starting GUI initialization
    setappdata(gui_hFigure,'InGUIInitialization',1);

    % Fetch GUIDE Application options
    gui_Options = getappdata(gui_hFigure,'GUIDEOptions');
    
    if ~isappdata(gui_hFigure,'GUIOnScreen')
        % Adjust background color
        if gui_Options.syscolorfig 
            set(gui_hFigure,'Color', get(0,'DefaultUicontrolBackgroundColor'));
        end

        % Generate HANDLES structure and store with GUIDATA
        guidata(gui_hFigure, guihandles(gui_hFigure));
    end
    
    % If user specified 'Visible','off' in p/v pairs, don't make the figure
    % visible.
    gui_MakeVisible = 1;
    for ind=1:2:length(varargin)
        if length(varargin) == ind
            break;
        end
        len1 = min(length('visible'),length(varargin{ind}));
        len2 = min(length('off'),length(varargin{ind+1}));
        if ischar(varargin{ind}) & ischar(varargin{ind+1}) & ...
                strncmpi(varargin{ind},'visible',len1) & len2 > 1
            if strncmpi(varargin{ind+1},'off',len2)
                gui_MakeVisible = 0;
            elseif strncmpi(varargin{ind+1},'on',len2)
                gui_MakeVisible = 1;
            end
        end
    end
    
    % Check for figure param value pairs
    for index=1:2:length(varargin)
        if length(varargin) == index
            break;
        end
        try, set(gui_hFigure, varargin{index}, varargin{index+1}), catch, break, end
    end

    % If handle visibility is set to 'callback', turn it on until finished
    % with OpeningFcn
    gui_HandleVisibility = get(gui_hFigure,'HandleVisibility');
    if strcmp(gui_HandleVisibility, 'callback')
        set(gui_hFigure,'HandleVisibility', 'on');
    end
    
    feval(gui_State.gui_OpeningFcn, gui_hFigure, [], guidata(gui_hFigure), varargin{:});
    
    if ishandle(gui_hFigure)
        % Update handle visibility
        set(gui_hFigure,'HandleVisibility', gui_HandleVisibility);
        
        % Make figure visible
        if gui_MakeVisible
            set(gui_hFigure, 'Visible', 'on')
            if gui_Options.singleton 
                setappdata(gui_hFigure,'GUIOnScreen', 1);
            end
        end

        % Done with GUI initialization
        rmappdata(gui_hFigure,'InGUIInitialization');
    end
    
    % If handle visibility is set to 'callback', turn it on until finished with
    % OutputFcn
    if ishandle(gui_hFigure)
        gui_HandleVisibility = get(gui_hFigure,'HandleVisibility');
        if strcmp(gui_HandleVisibility, 'callback')
            set(gui_hFigure,'HandleVisibility', 'on');
        end
        gui_Handles = guidata(gui_hFigure);
    else
        gui_Handles = [];
    end
    
    if nargout
        [varargout{1:nargout}] = feval(gui_State.gui_OutputFcn, gui_hFigure, [], gui_Handles);
    else
        feval(gui_State.gui_OutputFcn, gui_hFigure, [], gui_Handles);
    end
    
    if ishandle(gui_hFigure)
        set(gui_hFigure,'HandleVisibility', gui_HandleVisibility);
    end
end    

function gui_hFigure = local_openfig(name, singleton)
if nargin('openfig') == 3 
    gui_hFigure = openfig(name, singleton, 'auto');
else
    % OPENFIG did not accept 3rd input argument until R13,
    % toggle default figure visible to prevent the figure
    % from showing up too soon.
    gui_OldDefaultVisible = get(0,'defaultFigureVisible');
    set(0,'defaultFigureVisible','off');
    gui_hFigure = openfig(name, singleton);
    set(0,'defaultFigureVisible',gui_OldDefaultVisible);
end